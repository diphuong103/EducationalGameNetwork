package com.edugame.server.network;

import com.edugame.common.Protocol;
import com.edugame.server.database.FriendDAO;
import com.edugame.server.database.UserDAO;
import com.edugame.server.database.LeaderboardDAO;
import com.edugame.server.database.MessageDAO;

import com.edugame.server.model.Friend;
import com.edugame.server.model.User;
import com.google.gson.Gson;
import com.google.gson.JsonObject;

import java.io.*;
import java.net.Socket;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClientHandler implements Runnable {
    private Socket clientSocket;
    private BufferedReader reader;
    private PrintWriter writer;
    private Gson gson;
    private UserDAO userDAO;
    private LeaderboardDAO leaderboardDAO;
    private MessageDAO messageDAO;
    private User currentUser;
    private boolean running;
    private GameServer server;

    // üîπ DateTimeFormatter cho log
    private static final DateTimeFormatter LOG_TIME_FORMAT =
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

    public ClientHandler(Socket socket, GameServer server) {
        this.clientSocket = socket;
        this.server = server;
        this.gson = new Gson();
        this.userDAO = new UserDAO();
        this.leaderboardDAO = new LeaderboardDAO();
        this.messageDAO = new MessageDAO();
        this.running = true;

        try {
            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            writer = new PrintWriter(socket.getOutputStream(), true);

            logWithTime("‚úì New client connected: " + socket.getInetAddress());

        } catch (IOException e) {
            logWithTime("‚úó Error initializing client handler: " + e.getMessage());
        }
    }

    // üîπ Log v·ªõi timestamp
    private void logWithTime(String message) {
        String timestamp = LocalDateTime.now().format(LOG_TIME_FORMAT);
        System.out.println("[" + timestamp + "] " + message);
    }

    @Override
    public void run() {
        logWithTime("üü¢ ClientHandler thread STARTED, ID: " + Thread.currentThread().getId());

        try {
            String message;
            int messageCount = 0;

            while (running && (message = reader.readLine()) != null) {
                messageCount++;
                logWithTime("üì® [Handler-" + Thread.currentThread().getId() + "] Message #" + messageCount);
                handleMessage(message);
            }

            logWithTime("üî¥ ClientHandler loop ENDED after " + messageCount + " messages");

        } catch (IOException e) {
            logWithTime("‚úó Client disconnected: " + e.getMessage());
        } finally {
            handleLogout();
            disconnect();
        }
    }

    private void handleMessage(String message) {
        try {
            logWithTime("üîµ handleMessage() parsing: " + message.substring(0, Math.min(100, message.length())) + "...");

            JsonObject jsonMessage = gson.fromJson(message, JsonObject.class);
            String type = jsonMessage.get("type").getAsString();

            logWithTime("   üì¶ Type: " + type + " | User: " + (currentUser != null ? currentUser.getUsername() : "anonymous"));

            switch (type) {
                case Protocol.LOGIN:
                    logWithTime("   ‚Üí Calling handleLogin()");
                    handleLogin(jsonMessage);
                    break;

                case Protocol.REGISTER:
                    logWithTime("   ‚Üí Calling handleRegister()");
                    handleRegister(jsonMessage);
                    break;

                case Protocol.GET_LEADERBOARD:
                    logWithTime("   ‚Üí Calling handleGetLeaderboard()");
                    handleGetLeaderboard(jsonMessage);
                    break;

                case Protocol.GLOBAL_CHAT:
                    logWithTime("   ‚Üí Calling handleGlobalChat()");
                    handleGlobalChat(jsonMessage);
                    break;

                case Protocol.GET_MESSAGES:
                    logWithTime("   ‚Üí Calling handleGetMessages()");
                    handleGetMessages(jsonMessage);
                    break;

                case Protocol.SEND_MESSAGE:
                    logWithTime("   ‚Üí Calling handleSendMessage()");
                    handleSendMessage(jsonMessage);
                    break;

                case Protocol.MESSAGE_READ:
                    logWithTime("   ‚Üí Calling handleMarkAsRead()");
                    handleMarkAsRead(jsonMessage);
                    break;

                case Protocol.GET_PROFILE:
                    logWithTime("   ‚Üí Calling handleGetProfile()");
                    handleGetProfile(jsonMessage);
                    break;

                case Protocol.UPDATE_PROFILE:
                    logWithTime("   ‚Üí Calling handleUpdateProfile()");
                    handleUpdateProfile(jsonMessage);
                    break;
                case Protocol.SEARCH_USERS:
                    logWithTime("   ‚Üí Calling handleSearchUsers()");
                    handleSearchUsers(jsonMessage);
                    break;
                case Protocol.ADD_FRIEND:
                    logWithTime("   ‚Üí Calling handleAddFriend()");
                    handleAddFriend(jsonMessage);
                    break;

                case Protocol.ACCEPT_FRIEND:
                    logWithTime("   ‚Üí Calling handleAcceptFriend()");
                    handleAcceptFriend(jsonMessage);
                    break;

                case Protocol.REJECT_FRIEND:
                    logWithTime("   ‚Üí Calling handleRejectFriend()");
                    handleRejectFriend(jsonMessage);
                    break;

                case Protocol.REMOVE_FRIEND:
                    logWithTime("   ‚Üí Calling handleRemoveFriend()");
                    handleRemoveFriend(jsonMessage);
                    break;

                case Protocol.GET_FRIENDS_LIST:
                    logWithTime("   ‚Üí Calling handleGetFriendsList()");
                    handleGetFriendsList(jsonMessage);
                    break;

                case Protocol.GET_PENDING_REQUESTS:
                    logWithTime("   ‚Üí Calling handleGetPendingRequests()");
                    handleGetPendingRequests(jsonMessage);
                    break;

                case Protocol.LOGOUT:
                    logWithTime("   ‚Üí Calling handleLogout()");
                    handleLogout();
                    break;

                default:
                    logWithTime("   ‚ùì Unknown type: " + type);
                    sendError("Unknown message type: " + type);
            }

            logWithTime("   ‚úÖ handleMessage() completed for type: " + type);

        } catch (Exception e) {
            logWithTime("‚ùå Error handling message: " + e.getMessage());
            e.printStackTrace();
            sendError("Invalid message format");
        }
    }


    private void handleSearchUsers(JsonObject jsonMessage) {
        logWithTime("üîç SEARCH_USERS request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        String searchQuery = jsonMessage.has("query") ? jsonMessage.get("query").getAsString() : "";
        int limit = jsonMessage.has("limit") ? jsonMessage.get("limit").getAsInt() : 20;

        logWithTime("   üîé Query: \"" + searchQuery + "\" | Limit: " + limit);
        logWithTime("   üë§ Searching for user: " + currentUser.getUsername());

        if (searchQuery.trim().isEmpty()) {
            logWithTime("   ‚ùå Empty search query");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.SEARCH_USERS);
            response.put("success", false);
            response.put("message", "Vui l√≤ng nh·∫≠p t√™n ƒë·ªÉ t√¨m ki·∫øm!");
            sendMessage(response);
            return;
        }

        FriendDAO friendDAO = new FriendDAO();
        java.util.List<User> users = friendDAO.searchUsers(searchQuery, currentUser.getUserId(), limit);

        logWithTime("   ‚úÖ Found " + users.size() + " users");

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.SEARCH_USERS);
        response.put("success", true);
        response.put("query", searchQuery);

        java.util.List<Map<String, Object>> usersData = new java.util.ArrayList<>();

        for (User user : users) {
            Map<String, Object> userData = new HashMap<>();
            userData.put("userId", user.getUserId());
            userData.put("username", user.getUsername());
            userData.put("fullName", user.getFullName());
            userData.put("email", user.getEmail());
            userData.put("age", user.getAge());
            userData.put("avatarUrl", user.getAvatarUrl());
            userData.put("totalScore", user.getTotalScore());
            userData.put("mathScore", user.getMathScore());
            userData.put("englishScore", user.getEnglishScore());
            userData.put("literatureScore", user.getLiteratureScore());
            userData.put("totalGames", user.getTotalGames());
            userData.put("wins", user.getWins());
            userData.put("isOnline", user.isOnline());

            // L·∫•y tr·∫°ng th√°i b·∫°n b√®
            String friendshipStatus = friendDAO.getFriendshipStatus(currentUser.getUserId(), user.getUserId());
            userData.put("friendshipStatus", friendshipStatus);

            usersData.add(userData);
        }

        response.put("users", usersData);
        sendMessage(response);

        logWithTime("   ‚úÖ Search results sent");
    }

    /**
     * G·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n
     */
    private void handleAddFriend(JsonObject jsonMessage) {
        logWithTime("ü§ù ADD_FRIEND request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int targetUserId = jsonMessage.get("targetUserId").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ From: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üë§ To: User ID " + targetUserId);

        // Ki·ªÉm tra kh√¥ng th·ªÉ k·∫øt b·∫°n v·ªõi ch√≠nh m√¨nh
        if (currentUserId == targetUserId) {
            logWithTime("   ‚ùå Cannot add yourself as friend");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.ADD_FRIEND);
            response.put("success", false);
            response.put("message", "B·∫°n kh√¥ng th·ªÉ k·∫øt b·∫°n v·ªõi ch√≠nh m√¨nh!");
            sendMessage(response);
            return;
        }

        FriendDAO friendDAO = new FriendDAO();

        // Ki·ªÉm tra ƒë√£ l√† b·∫°n ch∆∞a
        if (friendDAO.isFriend(currentUserId, targetUserId)) {
            logWithTime("   ‚ö†Ô∏è Already friends");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.ADD_FRIEND);
            response.put("success", false);
            response.put("message", "C√°c b·∫°n ƒë√£ l√† b·∫°n b√® r·ªìi!");
            sendMessage(response);
            return;
        }

        // Ki·ªÉm tra ƒë√£ c√≥ l·ªùi m·ªùi ch∆∞a
        if (friendDAO.hasPendingRequest(currentUserId, targetUserId)) {
            logWithTime("   ‚ö†Ô∏è Pending request already exists");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.ADD_FRIEND);
            response.put("success", false);
            response.put("message", "ƒê√£ c√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒëang ch·ªù x·ª≠ l√Ω!");
            sendMessage(response);
            return;
        }

        // G·ª≠i l·ªùi m·ªùi
        boolean success = friendDAO.sendFriendRequest(currentUserId, targetUserId);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.ADD_FRIEND);
        response.put("success", success);
        response.put("message", success ? "ƒê√£ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n!" : "Kh√¥ng th·ªÉ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n!");
        response.put("targetUserId", targetUserId);

        sendMessage(response);

        if (success) {
            logWithTime("   ‚úÖ Friend request sent successfully");
        } else {
            logWithTime("   ‚ùå Failed to send friend request");
        }
    }

    /**
     * Ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n
     */
    private void handleAcceptFriend(JsonObject jsonMessage) {
        logWithTime("‚úÖ ACCEPT_FRIEND request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int friendId = jsonMessage.get("friendId").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üë§ Accepting request from: User ID " + friendId);

        FriendDAO friendDAO = new FriendDAO();
        boolean success = friendDAO.acceptFriendRequest(currentUserId, friendId);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.ACCEPT_FRIEND);
        response.put("success", success);
        response.put("message", success ? "ƒê√£ ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n!" : "Kh√¥ng th·ªÉ ch·∫•p nh·∫≠n l·ªùi m·ªùi!");
        response.put("friendId", friendId);

        sendMessage(response);

        if (success) {
            logWithTime("   ‚úÖ Friend request accepted");
        } else {
            logWithTime("   ‚ùå Failed to accept friend request");
        }
    }

    /**
     * T·ª´ ch·ªëi l·ªùi m·ªùi k·∫øt b·∫°n
     */
    private void handleRejectFriend(JsonObject jsonMessage) {
        logWithTime("‚ùå REJECT_FRIEND request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int friendId = jsonMessage.get("friendId").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üë§ Rejecting request from: User ID " + friendId);

        FriendDAO friendDAO = new FriendDAO();
        boolean success = friendDAO.rejectFriendRequest(currentUserId, friendId);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.REJECT_FRIEND);
        response.put("success", success);
        response.put("message", success ? "ƒê√£ t·ª´ ch·ªëi l·ªùi m·ªùi k·∫øt b·∫°n!" : "Kh√¥ng th·ªÉ t·ª´ ch·ªëi l·ªùi m·ªùi!");
        response.put("friendId", friendId);

        sendMessage(response);

        if (success) {
            logWithTime("   ‚úÖ Friend request rejected");
        } else {
            logWithTime("   ‚ùå Failed to reject friend request");
        }
    }

    /**
     * X√≥a b·∫°n b√®
     */
    private void handleRemoveFriend(JsonObject jsonMessage) {
        logWithTime("üóëÔ∏è REMOVE_FRIEND request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int friendId = jsonMessage.get("friendId").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üë§ Removing friend: User ID " + friendId);

        FriendDAO friendDAO = new FriendDAO();
        boolean success = friendDAO.removeFriend(currentUserId, friendId);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.REMOVE_FRIEND);
        response.put("success", success);
        response.put("message", success ? "ƒê√£ x√≥a b·∫°n b√®!" : "Kh√¥ng th·ªÉ x√≥a b·∫°n b√®!");
        response.put("friendId", friendId);

        sendMessage(response);

        if (success) {
            logWithTime("   ‚úÖ Friend removed successfully");
        } else {
            logWithTime("   ‚ùå Failed to remove friend");
        }
    }

    /**
     * L·∫•y danh s√°ch b·∫°n b√®
     */
    private void handleGetFriendsList(JsonObject jsonMessage) {
        logWithTime("üìã GET_FRIENDS_LIST request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int currentUserId = currentUser.getUserId();
        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");

        FriendDAO friendDAO = new FriendDAO();
        List<Friend> friends = friendDAO.getFriendsList(currentUserId);

        logWithTime("   ‚úÖ Found " + friends.size() + " friends");

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.GET_FRIENDS_LIST);
        response.put("success", true);

        List<Map<String, Object>> friendsData = new ArrayList<>();

        for (Friend friend : friends) {
            Map<String, Object> friendData = new HashMap<>();
            friendData.put("friendshipId", friend.getFriendshipId());
            friendData.put("userId", friend.getUserId() == currentUserId ? friend.getFriendId() : friend.getUserId());
            friendData.put("username", friend.getUsername());
            friendData.put("fullName", friend.getFullName());
            friendData.put("avatarUrl", friend.getAvatarUrl());
            friendData.put("totalScore", friend.getTotalScore());
            friendData.put("isOnline", friend.isOnline());
            friendData.put("createdAt", friend.getCreatedAt().toString());

            friendsData.add(friendData);
        }

        response.put("friends", friendsData);
        response.put("count", friends.size());

        sendMessage(response);
        logWithTime("   ‚úÖ Friends list sent");
    }

    /**
     * L·∫•y danh s√°ch l·ªùi m·ªùi k·∫øt b·∫°n ƒëang ch·ªù
     */
    private void handleGetPendingRequests(JsonObject jsonMessage) {
        logWithTime("üì¨ GET_PENDING_REQUESTS request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int currentUserId = currentUser.getUserId();
        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");

        FriendDAO friendDAO = new FriendDAO();
        List<Friend> requests = friendDAO.getPendingRequests(currentUserId);

        logWithTime("   ‚úÖ Found " + requests.size() + " pending requests");

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.GET_PENDING_REQUESTS);
        response.put("success", true);

        List<Map<String, Object>> requestsData = new ArrayList<>();

        for (Friend request : requests) {
            Map<String, Object> requestData = new HashMap<>();
            requestData.put("friendshipId", request.getFriendshipId());
            requestData.put("userId", request.getUserId());
            requestData.put("username", request.getUsername());
            requestData.put("fullName", request.getFullName());
            requestData.put("avatarUrl", request.getAvatarUrl());
            requestData.put("totalScore", request.getTotalScore());
            requestData.put("isOnline", request.isOnline());
            requestData.put("createdAt", request.getCreatedAt().toString());

            requestsData.add(requestData);
        }

        response.put("requests", requestsData);
        response.put("count", requests.size());

        sendMessage(response);
        logWithTime("   ‚úÖ Pending requests sent");
    }

    private void handleUpdateProfile(JsonObject jsonMessage) {
        logWithTime("üîß UPDATE_PROFILE request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int userId = currentUser.getUserId();
        String oldName = currentUser.getFullName();
        String oldAvatar = currentUser.getAvatarUrl();

        String newName = jsonMessage.has("fullName") ? jsonMessage.get("fullName").getAsString() : oldName;
        String newAvatar = jsonMessage.has("avatarUrl") ? jsonMessage.get("avatarUrl").getAsString() : oldAvatar;

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + userId + ")");
        logWithTime("   üìù Name: \"" + oldName + "\" ‚Üí \"" + newName + "\"");
        logWithTime("   üñºÔ∏è Avatar: \"" + (oldAvatar != null ? oldAvatar.substring(0, Math.min(50, oldAvatar.length())) : "null") + "...\"");
        logWithTime("          ‚Üí \"" + (newAvatar != null ? newAvatar.substring(0, Math.min(50, newAvatar.length())) : "null") + "...\"");

        boolean success = userDAO.updateUserProfile(userId, newName, newAvatar);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.UPDATE_PROFILE);
        response.put("success", success);
        response.put("message", success ? "C·∫≠p nh·∫≠t h·ªì s∆° th√†nh c√¥ng!" : "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t h·ªì s∆°!");

        if (success) {
            response.put("fullName", newName);
            response.put("avatarUrl", newAvatar);

            // Update current session
            currentUser.setFullName(newName);
            currentUser.setAvatarUrl(newAvatar);

            logWithTime("   ‚úÖ Profile updated successfully");
            logWithTime("      New Name: " + newName);
            logWithTime("      New Avatar: " + (newAvatar != null ? newAvatar.substring(0, Math.min(50, newAvatar.length())) : "null"));
        } else {
            logWithTime("   ‚ùå Profile update FAILED in database");
        }

        sendMessage(response);
    }

    private void handleGetProfile(JsonObject jsonMessage) {
        logWithTime("üîç GET_PROFILE request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå currentUser is NULL!");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUser.getUserId() + ")");

        int userId = currentUser.getUserId();
        User user = userDAO.getUserById(userId);

        if (user == null) {
            logWithTime("   ‚ùå User not found in database!");
            sendError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng!");
            return;
        }

        logWithTime("   ‚úÖ User loaded from DB:");
        logWithTime("      Name: " + user.getFullName());
        logWithTime("      Avatar: " + (user.getAvatarUrl() != null ? user.getAvatarUrl().substring(0, Math.min(50, user.getAvatarUrl().length())) : "null"));
        logWithTime("      Score: " + user.getTotalScore());
        logWithTime("      Games: " + user.getTotalGames() + " | Wins: " + user.getWins());

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.GET_PROFILE);
        response.put("success", true);
        response.put("userId", user.getUserId());
        response.put("username", user.getUsername());
        response.put("fullName", user.getFullName());
        response.put("age", user.getAge());
        response.put("email", user.getEmail());
        response.put("avatarUrl", user.getAvatarUrl());
        response.put("totalScore", user.getTotalScore());
        response.put("mathScore", user.getMathScore());
        response.put("englishScore", user.getEnglishScore());
        response.put("literatureScore", user.getLiteratureScore());
        response.put("totalGames", user.getTotalGames());
        response.put("wins", user.getWins());

        sendMessage(response);
        logWithTime("   ‚úÖ GET_PROFILE response sent");
    }

    private void handleLogin(JsonObject jsonMessage) {
        String username = jsonMessage.get("username").getAsString();
        String password = jsonMessage.get("password").getAsString();

        logWithTime("üîê LOGIN attempt: " + username);

        User user = userDAO.loginUser(username, password);

        if (user != null) {
            currentUser = user;

            logWithTime("   ‚úÖ Login successful");
            logWithTime("      User: " + user.getUsername() + " | Name: " + user.getFullName());
            logWithTime("      Avatar: " + (user.getAvatarUrl() != null ? user.getAvatarUrl().substring(0, Math.min(50, user.getAvatarUrl().length())) : "null"));

            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.LOGIN);
            response.put("success", true);
            response.put("userId", user.getUserId());
            response.put("username", user.getUsername());
            response.put("fullName", user.getFullName());
            response.put("age", user.getAge());
            response.put("email", user.getEmail());
            response.put("avatarUrl", user.getAvatarUrl());
            response.put("totalScore", user.getTotalScore());
            response.put("mathScore", user.getMathScore());
            response.put("englishScore", user.getEnglishScore());
            response.put("literatureScore", user.getLiteratureScore());
            response.put("totalGames", user.getTotalGames());
            response.put("wins", user.getWins());
            response.put("message", "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!");

            sendMessage(response);

        } else {
            logWithTime("   ‚ùå Login failed: Invalid credentials");

            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.LOGIN);
            response.put("success", false);
            response.put("message", "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!");

            sendMessage(response);
        }
    }

    private void handleRegister(JsonObject jsonMessage) {
        String username = jsonMessage.get("username").getAsString();
        String password = jsonMessage.get("password").getAsString();
        String email = jsonMessage.get("email").getAsString();
        String fullName = jsonMessage.get("fullName").getAsString();
        String age = jsonMessage.get("age").getAsString();
        String avatar = jsonMessage.get("avatar").getAsString();

        logWithTime("üìù REGISTER attempt: " + username);
        logWithTime("   Name: " + fullName + " | Avatar: " + avatar);

        if (userDAO.usernameExists(username)) {
            logWithTime("   ‚ùå Username already exists");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.REGISTER);
            response.put("success", false);
            response.put("message", "T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i!");
            sendMessage(response);
            return;
        }

        if (!email.isEmpty() && userDAO.emailExists(email)) {
            logWithTime("   ‚ùå Email already exists");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.REGISTER);
            response.put("success", false);
            response.put("message", "Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng!");
            sendMessage(response);
            return;
        }

        boolean success = userDAO.registerUser(username, password, email, fullName, age, avatar);

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.REGISTER);
        response.put("success", success);
        response.put("message", success ? "ƒêƒÉng k√Ω th√†nh c√¥ng!" : "ƒêƒÉng k√Ω th·∫•t b·∫°i!");

        sendMessage(response);

        if (success) {
            logWithTime("   ‚úÖ Registration successful");
        } else {
            logWithTime("   ‚ùå Registration failed");
        }
    }

    private void handleLogout() {
        try {
            if (currentUser != null) {
                logWithTime("üö™ LOGOUT: " + currentUser.getUsername());
                userDAO.updateOnlineStatus(currentUser.getUserId(), false);
                currentUser = null;
            }

            running = false;

            if (clientSocket != null && !clientSocket.isClosed()) {
                clientSocket.close();
                logWithTime("   üîí Socket closed");
            }

        } catch (Exception e) {
            logWithTime("   ‚ùå Error during logout: " + e.getMessage());
        }
    }

    private void handleGetLeaderboard(JsonObject jsonMessage) {
        try {
            String subject = jsonMessage.has("subject") ? jsonMessage.get("subject").getAsString() : "total";
            int limit = jsonMessage.has("limit") ? jsonMessage.get("limit").getAsInt() : 50;

            logWithTime("üìä GET_LEADERBOARD: subject=" + subject + ", limit=" + limit);

            java.util.List<User> leaderboard = leaderboardDAO.getLeaderboardBySubject(subject, limit);

            if (leaderboard == null || leaderboard.isEmpty()) {
                logWithTime("   ‚ö†Ô∏è No users found");
            } else {
                logWithTime("   ‚úÖ Found " + leaderboard.size() + " users");
            }

            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.GET_LEADERBOARD);
            response.put("success", true);
            response.put("subject", subject);

            java.util.List<Map<String, Object>> usersData = new java.util.ArrayList<>();

            for (User user : leaderboard) {
                Map<String, Object> u = new HashMap<>();
                u.put("userId", user.getUserId());
                u.put("username", user.getUsername());
                u.put("fullName", user.getFullName());
                u.put("avatarUrl", user.getAvatarUrl());
                u.put("isOnline", user.isOnline());

                int score;
                switch (subject.toLowerCase()) {
                    case "math":
                        score = user.getMathScore();
                        break;
                    case "english":
                        score = user.getEnglishScore();
                        break;
                    case "literature":
                        score = user.getLiteratureScore();
                        break;
                    default:
                        score = user.getTotalScore();
                        break;
                }

                u.put("totalScore", score);
                usersData.add(u);
            }

            response.put("leaderboard", usersData);
            sendMessage(response);

            logWithTime("   ‚úÖ Leaderboard sent");
        } catch (Exception e) {
            logWithTime("   ‚ùå Error: " + e.getMessage());
            e.printStackTrace();
            sendError("Kh√¥ng th·ªÉ t·∫£i b·∫£ng x·∫øp h·∫°ng");
        }
    }

    /// ////////////Chat /////////////
    private void handleGlobalChat(JsonObject jsonMessage) {
        if (currentUser == null) {
            sendError("B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ƒë·ªÉ g·ª≠i tin nh·∫Øn!");
            return;
        }

        String message = jsonMessage.get("message").getAsString();
        String username = currentUser.getUsername();

        if (message.trim().isEmpty()) {
            return;
        }

        if (message.length() > 500) {
            sendError("Tin nh·∫Øn qu√° d√†i! (t·ªëi ƒëa 500 k√Ω t·ª±)");
            return;
        }

        Map<String, Object> chatMessage = new HashMap<>();
        chatMessage.put("type", "GLOBAL_CHAT");
        chatMessage.put("username", username);
        chatMessage.put("message", message);

        server.broadcastMessage(chatMessage, this);

        logWithTime("üí¨ CHAT [" + username + "]: " + message.substring(0, Math.min(50, message.length())));
    }

    void sendMessage(Map<String, Object> data) {
        try {
            if (writer != null && !writer.checkError()) {
                String json = gson.toJson(data);
                writer.println(json);
                writer.flush();

                if (!writer.checkError()) {
                    logWithTime("   üì§ Response sent: type=" + data.get("type") + ", size=" + json.length() + " bytes");
                } else {
                    logWithTime("   ‚ùå Writer error after flush");
                }

            } else {
                logWithTime("   ‚ùå Writer unavailable");
            }
        } catch (Exception e) {
            logWithTime("   ‚ùå sendMessage error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void sendError(String errorMessage) {
        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.ERROR);
        response.put("success", false);
        response.put("message", errorMessage);
        sendMessage(response);
    }

    /**
     * Handle GET_MESSAGES - L·∫•y l·ªãch s·ª≠ chat
     */
    private void handleGetMessages(JsonObject jsonMessage) {
        logWithTime("üí¨ GET_MESSAGES request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int friendId = jsonMessage.get("friendId").getAsInt();
        int limit = jsonMessage.get("limit").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üë§ Getting messages with: User ID " + friendId);
        logWithTime("   üìä Limit: " + limit);

        List<com.edugame.server.model.Message> messages = messageDAO.getMessages(currentUserId, friendId, limit);

        logWithTime("   ‚úÖ Found " + messages.size() + " messages");

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.GET_MESSAGES);
        response.put("success", true);

        List<Map<String, Object>> messagesData = new ArrayList<>();

        for (com.edugame.server.model.Message msg : messages) {
            Map<String, Object> msgData = new HashMap<>();
            msgData.put("messageId", msg.getMessageId());
            msgData.put("senderId", msg.getSenderId());
            msgData.put("receiverId", msg.getReceiverId());
            msgData.put("content", msg.getContent());
            msgData.put("sentAt", msg.getSentAt().toString());
            msgData.put("isRead", msg.isRead());

            if (msg.getSenderUsername() != null) {
                msgData.put("senderName", msg.getSenderName());
                msgData.put("senderAvatar", msg.getSenderAvatar());
            }

            messagesData.add(msgData);
        }

        response.put("messages", messagesData);
        sendMessage(response);

        logWithTime("   ‚úÖ Messages sent");
    }

    /**
     * Handle SEND_MESSAGE - G·ª≠i tin nh·∫Øn
     */
    private void handleSendMessage(JsonObject jsonMessage) {
        logWithTime("üí¨ SEND_MESSAGE request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            sendError("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p!");
            return;
        }

        int receiverId = jsonMessage.get("receiverId").getAsInt();
        String content = jsonMessage.get("content").getAsString();
        int senderId = currentUser.getUserId();

        logWithTime("   üë§ From: " + currentUser.getUsername() + " (ID: " + senderId + ")");
        logWithTime("   üë§ To: User ID " + receiverId);
        logWithTime("   üí¨ Content: " + content.substring(0, Math.min(50, content.length())));

        // Validate
        if (content.trim().isEmpty()) {
            logWithTime("   ‚ùå Empty message");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.SEND_MESSAGE);
            response.put("success", false);
            response.put("message", "Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!");
            sendMessage(response);
            return;
        }

        if (content.length() > 1000) {
            logWithTime("   ‚ùå Message too long");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.SEND_MESSAGE);
            response.put("success", false);
            response.put("message", "Tin nh·∫Øn qu√° d√†i (t·ªëi ƒëa 1000 k√Ω t·ª±)!");
            sendMessage(response);
            return;
        }

        // ‚úÖ 1. Save to database
        com.edugame.server.model.Message savedMessage = messageDAO.sendMessage(senderId, receiverId, content);

        if (savedMessage != null) {
            logWithTime("   ‚úÖ Message saved to database (ID=" + savedMessage.getMessageId() + ")");

            // ‚úÖ 2. Send success response to SENDER
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.SEND_MESSAGE);
            response.put("success", true);
            response.put("messageId", savedMessage.getMessageId());
            response.put("sentAt", savedMessage.getSentAt().toString());
            sendMessage(response);
            logWithTime("   ‚úÖ SUCCESS response sent to SENDER");

            // ‚úÖ 3. Get sender info
            User senderUser = userDAO.getUserById(senderId);
            String senderName = (senderUser != null) ? senderUser.getFullName() : currentUser.getFullName();

            logWithTime("   üìù Sender name: " + senderName);

            // ‚úÖ 4. Create NEW_MESSAGE notification
            Map<String, Object> newMessageNotification = new HashMap<>();
            newMessageNotification.put("type", Protocol.NEW_MESSAGE);
            newMessageNotification.put("messageId", savedMessage.getMessageId());
            newMessageNotification.put("senderId", senderId);
            newMessageNotification.put("senderName", senderName);
            newMessageNotification.put("content", content);
            newMessageNotification.put("sentAt", savedMessage.getSentAt().toString());

            logWithTime("   üì§ Attempting to send NEW_MESSAGE to receiverId=" + receiverId);

            // ‚úÖ 5. Send to receiver by USER_ID (QUAN TR·ªåNG - KH√îNG d√πng String.valueOf)
            boolean sentToReceiver = server.sendToUserId(receiverId, newMessageNotification);

            if (sentToReceiver) {
                logWithTime("   ‚úÖ‚úÖ‚úÖ NEW_MESSAGE sent successfully to receiverId=" + receiverId);
            } else {
                logWithTime("   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è RECEIVER OFFLINE or NOT FOUND (userId=" + receiverId + ")");
            }

        } else {
            logWithTime("   ‚ùå Failed to save message");
            Map<String, Object> response = new HashMap<>();
            response.put("type", Protocol.SEND_MESSAGE);
            response.put("success", false);
            response.put("message", "Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn!");
            sendMessage(response);
        }
    }

    /**
     * Handle MESSAGE_READ - ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc
     */
    private void handleMarkAsRead(JsonObject jsonMessage) {
        logWithTime("‚úì MESSAGE_READ request received");

        if (currentUser == null) {
            logWithTime("   ‚ùå User not logged in");
            return;
        }

        int senderId = jsonMessage.get("senderId").getAsInt();
        int currentUserId = currentUser.getUserId();

        logWithTime("   üë§ User: " + currentUser.getUsername() + " (ID: " + currentUserId + ")");
        logWithTime("   üì® Marking messages from: User ID " + senderId);

        int updatedCount = messageDAO.markAllAsRead(currentUserId, senderId);

        logWithTime("   ‚úÖ Marked " + updatedCount + " messages as read");

        Map<String, Object> response = new HashMap<>();
        response.put("type", Protocol.MESSAGE_READ);
        response.put("success", true);
        response.put("updatedCount", updatedCount);
        sendMessage(response);
    }

    private void disconnect() {
        try {
            if (currentUser != null) {
                userDAO.updateOnlineStatus(currentUser.getUserId(), false);
            }

            running = false;

            if (reader != null) reader.close();
            if (writer != null) writer.close();
            if (clientSocket != null && !clientSocket.isClosed()) {
                clientSocket.close();
            }

            logWithTime("‚úì Client disconnected: " +
                    (currentUser != null ? currentUser.getUsername() : "anonymous"));

        } catch (IOException e) {
            logWithTime("‚úó Error disconnecting: " + e.getMessage());
        }
    }

    public User getCurrentUser() {
        return currentUser;
    }

    public boolean isRunning() {
        return running;
    }
}
